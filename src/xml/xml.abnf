; xml.abnf - dim xml
;
; rules to parse xml
%root = document
%api.prefix = XmlBase
%api.namespace = Dim::Detail

; abnf grammer rules for xml

; Document
document = [utf8-bom] prolog element *Misc     ; 1
utf8-bom = %xef.bb.bf

; Character Range and White Space
ws = SP / HTAB / CR / LF
Char = ws / %x21-7f     ; 2
S = 1*ws         ; 3

; Names and Tokens
NameStartChar = ":" / ALPHA / "_"   ; 4
NameChar = NameStartChar / "-" / "." / DIGIT ; 4a
Name = NameStartChar *(NameChar)    ; 5
Nmtoken = 1*NameChar ; 7

; Literals
EntityValue = ; [9]
    DQUOTE *(Char-not-AMP-DQUOTE-PCT / PEReference / Reference) DQUOTE
    / "'" *(Char-not-AMP-APOS-PCT / PEReference / Reference) "'"
Char-not-AMP-DQUOTE-PCT = ws 
    / %x21 
    ; 22 - DQUOTE
    / %x23-24 
    ; 25 - PCT
    ; 26 - AMP
    / %x27-7f
Char-not-AMP-APOS-PCT = ws
    / %x21-24 
    ; 25 - PCT
    ; 26 - AMP
    ; 27 - APOS
    / %x28-7f
AttValue = DQUOTE *(Char-not-ws-AMP-DQUOTE-LT / ws / Reference) DQUOTE ; [10]
    / "'" *(Char-not-ws-AMP-APOS-LT / ws / Reference) "'"
Char-not-ws-AMP-DQUOTE-LT = 
	%x21 
    ; 22 - DQUOTE
    / %x23-25 
    ; 26 - AMP
    / %x27-3b 
    ; 3c - LT
    / %x3d-7f
Char-not-ws-AMP-APOS-LT = 
	%x21-25
    ; 26 - AMP
    ; 27 - APOS
    / %x28-3b 
    ; 3c - LT
    / %x3d-7f
SystemLiteral = DQUOTE *Char-not-DQUOTE DQUOTE / "'" *Char-not-APOS "'" ; [11]
Char-not-DQUOTE = ws
    / %x21 
    ; 22 - DQUOTE
    / %x23-7f
Char-not-APOS = ws
    / %x21-26 
    ; 27 - APOS
    / %x28-7f
PubidLiteral = DQUOTE *PubidChar DQUOTE / "'" *PubidChar-not-APOS "'" ; [12]
PubidChar-not-APOS = SP / CR / LF / ALPHA / DIGIT
    / "-" / "(" / ")" / "+" / "," / "." / "/" / ":" / "=" / "?" 
    / ";" / "!" / "*" / "#" / "@" / "$" / "_" / "%"
PubidChar = PubidChar-not-APOS / "'" ; [13]

; Attribute Value
attrValue = DQUOTE attrText DQUOTE / "'" attrTextApos "'" ; [10]
	{ Start, End }
attrText = [attrInPlace] *((Reference / normalizable-ws) [attrCopy])
attrInPlace = *Char-not-ws-AMP-DQUOTE-LT { End }
attrCopy = *Char-not-ws-AMP-DQUOTE-LT { Char }
attrTextApos = [attrInPlaceApos] *(Reference [attrCopyApos]) 
attrInPlaceApos = *Char-not-ws-AMP-APOS-LT { End, As = attrInPlace }
attrCopyApos = *Char-not-ws-AMP-APOS-LT { Char, As = attrCopy }
normalizable-ws = ws { Char }

; Character Data
CharData = *(Char-not-AMP-LT-RBRACKET ; [14]
    / 1*"]" Char-not-AMP-GT-LT) 
    *"]" { Char }
Char-not-AMP-LT-RBRACKET = ws
    / %x21-25 
    ; 26 - AMP
    / %x27-3b 
    ; 3c - LT
    / %x3d-5c 
    ; 5d - RBRACKET
    / %x5e-7f
Char-not-AMP-GT-LT = ws
    / %x21-25 
    ; 26 - AMP
    / %x27-3b 
    ; 3c - LT
    / %x3d 
    ; 3e - GT
    / %x3f-7f

; Comments
Comment = "<!--" *(Char-not-DASH  / ("-" Char-not-DASH) ) "-->" ; [15]
Char-not-DASH = ws
    / %x21-2c 
    ; 2d - DASH
    / %x2e-7f

; Processing Instructions
PI = "<?" PITarget [S piValue] "?>" ; [16]
PITarget = NameStartChar-not-X *NameChar ; [17]
    / "X" [NameChar-not-M *NameChar]
    / "XM" [NameChar-not-L *NameChar]
    / "XML" 1*NameChar
NameStartChar-not-X = %x41-57 / %x59-5a / %x61-77 / %x79-7a / ":" / "_"
NameChar-not-M = %x41-4c / %x4e-5a / %x61-6c / %x6e-7a / ":" / "_" / "-" 
    / "." / DIGIT
NameChar-not-L = %x41-4b / %x4d-5a / %x61-6b / %x6d-7a / ":" / "_" / "-" 
    / "." / DIGIT
piValue = *(Char-not-QMARK / "?" Char-not-GT)
Char-not-QMARK = ws
    / %x21-3e 
    ; 3f - QMARK
    / %x40-7f
Char-not-GT = ws
    / %x21-3d 
    ; 3e - GT
    / %x3f-7f

; CData Sections
CDSect = CDStart CDataWithEnd ; [18]
CDStart = %s"<![CDATA[" ; [19]
CDataWithEnd = CData CDEnd { Start, End }
CData = *(Char-not-RBRACKET  ; [20]
    / "]" Char-not-RBRACKET 
    / "]]" Char-not-GT-RBRACKET)
    *"]"
Char-not-RBRACKET = ws
    / %x21-5c
    ; 5d - RBRACKET
    / %x5e-7f
Char-not-GT-RBRACKET = ws
    / %x21-3d 
    ; 3e - GT
    / %x3f-5c
    ; 5d - RBRACKET 
    / %x5e-7f
CDEnd = "]]>" ; [21]

; Prolog
prolog = [XMLDecl] *Misc [doctypedecl *Misc] ; [22]
XMLDecl = %s"<?xml" VersionInfo [EncodingDecl] [SDDecl] [S] "?>" ; [23]
VersionInfo = S %s"version" Eq ; [24]
    ("'" VersionNum "'" / DQUOTE VersionNum DQUOTE)
Eq = [S] "=" [S] ; [25]
VersionNum = "1." 1*DIGIT ; [26]
Misc = Comment / PI / S ; [27]

; Document Type Definition
doctypedecl = %s"<!DOCTYPE" S Name [S ExternalID] [S]
    [ "[" intSubset "]" [S] ] ">" ; [28]
DeclSep = PEReference / S ; [28a]
intSubset = *(markupdecl / DeclSep) ; [28b]
markupdecl = elementdecl / AttlistDecl / EntityDecl / NotationDecl / PI 
    / Comment ; [29]

; External Subset
extSubset = [TextDecl] extSubsetDecl ; [30]
extSubsetDecl = *(markupdecl / conditionalSect / DeclSep) ; [31]

; Standalone Document Declaration
SDDecl = S %s"standalone" Eq ; [32]
    ("'" (%s"yes" / %s"no") "'" / DQUOTE (%s"yes" / %s"no") DQUOTE)

; Element
element = EmptyElemTag / STag element-tail { End } ; [39]
element-tail = content ETag { Function }
STag = "<" elemName *(S Attribute) [S] ">" ; [40]
Attribute = attrName Eq attrValue ; [41]
attrName = Name { Start, End }
ETag = "</" Name [S] ">" ; [42]
content = [elemText] *((element / PI / Comment / CDSect) [elemText]) ; [43]
elemText = *(CharData / Reference) { Start, End }
EmptyElemTag = "<" elemName *(S Attribute) [S] "/>" ; [44]
elemName = Name { Start, End }

; Element Type Declaration
elementdecl = %s"<!ELEMENT" S Name S contentspec [S] ">" ; [45]
contentspec = %s"EMPTY" / %s"ANY" / Mixed / children ; [46]
children = (choice / seq) ["?" / "*" / "+"] ; [47]
cp = (Name / choice / seq) ["?" / "*" / "+"] { Function } ; [48]
choice = "(" [S] cp 1*([S] "|" [S] cp) [S] ")" ; [49]
seq = "(" [S] cp *([S] "," [S] cp) [S] ")" ; [50]
Mixed = "(" [S] %s"#PCDATA" *([S] "|" [S] Name) [S] ")*" ; [51]
    / "(" [S] %s"#PCDATA" [S] ")"

; Attribute-list Declaration
AttlistDecl = %s"<!ATTLIST" S Name *AttDef [S] ">" ; [52]
AttDef = S Name S AttType S DefaultDecl ; [53]
AttType = StringType / TokenizedType / EnumeratedType ; [54]
StringType = %s"CDATA" ; [55]
TokenizedType = %s"ID" / %s"IDREF" / %s"IDREFS" / %s"ENTITY" ; [56]
    / %s"ENTITIES" / %s"NMTOKEN" / %s"NMTOKENS"
EnumeratedType = NotationType / Enumeration ; [57]
NotationType = %s"NOTATION" S "(" [S] Name *([S] "|" [S] Name) [S] ")" ; [58]
Enumeration = "(" [S] Nmtoken *([S] "|" [S] Nmtoken) [S] ")" ; [59]
DefaultDecl = %s"#REQUIRED" / %s"#IMPLIED" / [%s"#FIXED" S] AttValue ; [60]

; Conditional Section
conditionalSect = includeSect / ignoreSect ; [61]
includeSect = "<![" [S] %s"INCLUDE" [S] "[" extSubsetDecl "]]>" ; [62]
ignoreSect = "<![" [S] %s"IGNORE" [S] "[" *ignoreSectContents "]]>" ; [63]
ignoreSectContents = Ignore *("<![" ignoreSectContents "]]>" Ignore) ; [64]
Ignore = *(Char-not-LT-RBRACKET ; [65]
    / "<" Char-not-BANG-RBRACKET / "<!" Char-not-LBRACKET-RBRACKET
    / "]" Char-not-LT-RBRACKET / "]]" Char-not-GT-LT-RBRACKET
    ) ["<" ["!"] / *"]"]
Char-not-LT-RBRACKET = ws
    / %x21-3b 
    ; 3c - LT
    / %x3d-5c
    ; 5d - RBRACKET 
    / %x5e-7f
Char-not-BANG-RBRACKET = ws
    ; 21 - BANG
    / %x22-5c
    ; 5d - RBRACKET
    / %x5e-7f
Char-not-LBRACKET-RBRACKET = ws
    / %x21-5a
    ; 5b - LBRACKET
    / %x5c
    ; 5d - RBRACKET
    / %x5e-7f
Char-not-GT-LT-RBRACKET = ws
    / %x21-3b 
    ; 3c - LT
    / %x3d
    ; 3e - GT
    / %x3f-5c
    ; 5d - RBRACKET 
    / %x5e-7f

; Character and Entity Reference
CharRef = "&#" 1*DIGIT ";" / "&#" %x78 1*HEXDIG ";" ; [66]
Reference = EntityRef / CharRef ; [67]
EntityRef = entityApos / entityQuot / entityGt / entityLt / entityAmp ; [68]
    / entityOther
entityApos = %s"&apos;" { End }
entityQuot = %s"&quot;" { End }
entityGt = %s"&gt;" { End }
entityLt = %s"&lt;" { End }
entityAmp = %s"&amp;" { End }
entityOther = "&" Name ";" { End }
PEReference = "%" Name ";" ; [69]

; Entity Declaration
EntityDecl = GEDecl / PEDecl ; [70]
GEDecl = %s"<!ENTITY" S Name S EntityDef [S] ">" ; [71]
PEDecl = %s"<!ENTITY" S "%" S Name S PEDef [S] ">" ; [72]
EntityDef = EntityValue / ExternalID [NDataDecl] ; [73]
PEDef = EntityValue / ExternalID ; [74]
ExternalID = %s"SYSTEM" S SystemLiteral ; [75]
    / %s"PUBLIC" S PubidLiteral S SystemLiteral
NDataDecl = S %s"NDATA" S Name ; [76]

; Text Declaration
TextDecl = %s"<?xml" [VersionInfo] EncodingDecl [S] "?>" ; [77]

; Well-Formed External Parsed Entity
extParsedEnt = [TextDecl] content ; [78]

; Encoding Declaration
EncodingDecl = S %s"encoding" Eq ; [80]
    (DQUOTE EncName DQUOTE / "'" EncName "'")
EncName = ALPHA *(ALPHA / DIGIT / "." / "_" / "-") ; [81]

; Notation Declarations
NotationDecl = %s"<!NOTATION" S Name S (ExternalID / PublicID) [S] ">" ; [82]
PublicID = %s"PUBLIC" S PubidLiteral ; [83]
