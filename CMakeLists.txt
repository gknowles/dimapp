# CMakeLists.txt - general project generator
#
# Copyright Glen Knowles 2016 - 2017.
# Distributed under the Boost Software License, Version 1.0.
#
# Use this one file *unmodified* for all projects that follow the convections.
# All the careful tweaking is for Visual Studio, but it works on linux with 
# both gcc and clang (at least well enough to do travis builds :P).
#
# Project layout:
#   /<project_name>
#   /<project_name>/CMakeLists.txt - this file
#   /<project_name>/CMakeDeps.cmake - made by this file (source controlled)
#   /<project_name>/libs/<lib_project_name>/**
#   /<project_name>/libs/${PROJECT_NAME}/config.h
#       has special transformation
#   /<project_name>/tests/<test_project_name>/**
#   /<project_name>/tools/<tool_project_name>/**
#   /<project_name>/vendor/<vendor_project_name>/
#       if /<project_name>/vendor/<vendor_project_name>/CMakeLists.txt exists
#
# Code files:
# Source files are expected to be "*.cpp" and "*.h".
#
# Precompiled headers:
# If a lib, test, or tool has a "pch.h" it should also have a "pch.cpp", and 
# it's cpp files will (under msvc) have "/Yupch.h" - except pch.cpp which gets 
# "/Ycpch.h".
#
# Building libraries:
# If a library has no cpp files a non-building custom target is made for it 
# instead of a lib target (good for header only libs).
# For library builds the DIM_LIB_SOURCE macro is defined, used in combination
# with DIM_LIB_DYN_LINK to help mark up the interface with the correct 
# dllexport/dllimport attributes.
# 
# Testing:
# CTest will run all tests, and pass them the "--test" argument.
#
# Installing:
# By default nothing is installed. Installation of libs, tools, and tests
# are enabled using the INSTALL_LIBS, INSTALL_TOOLS, and INSTALL_TESTS options
# respectively. Install creates the following (vcpkg conventions):
#   include - subdir for each lib containing all of its headers except those 
#             like "*int.h"
#   include/${PROJECT_NAME}/config.h - if it (and they) exist, the following 
#           lines are commented/uncommented according to the selected options.
#       "#define DIM_LIB_DYN_LINK" - BUILD_SHARED_LIBS
#       "#define DIM_LIB_WINAPI_FAMILY_APP - WINDOWS_STORE
#   bin - only release build targets
#       libs with BUILD_SHARED_LIBS: *.dll and *.pdb
#       libs otherwise: no files
#       tools and tests: *.exe and *.pdb
#   lib - only release build targets
#       libs with BUILD_SHARED_LIBS: *.lib
#       libs otherwise: *.lib and *.pdb
#   debug/bin - like bin above, but debug targets
#   debug/lib - like lib above, but debug targets
#
# Vendor submodules:
# add_subdirectory is called for every vendor project directory that has
# a CMakeLists.txt file. It is expected to be a compatible version of this
# file, and only it's lib projects will be included in the root solution. 

cmake_minimum_required (VERSION 3.6)
option(LINK_STATIC_RUNTIME "Link with static c++ runtime" ON)
option(BUILD_SHARED_LIBS "Build DLLs instead of static libs" OFF)
option(BUILD_UNICODE "Build with unicode charset" OFF)
option(INSTALL_LIBS "Install includes libs" OFF)
option(INSTALL_TOOLS "Install includes tool binaries" OFF)
option(INSTALL_TESTS "Install includes test binaries" OFF)

# For internal use by this script
option(RECURSIVE_GENERATE "Recursive call to cmake" OFF)

# Reference to suppress "not used" warning when manually specified
set(tmp "${CMAKE_BUILD_TYPE}")      # not used (vcpkg sets it)
set(tmp "${LINK_STATIC_RUNTIME}")   # not used by gcc or clang builds


#############################################################################
#
#   Functions
#
####

# Compare the new contents with the existing file, if it exists and is the 
# same we don't want to trigger a make by changing its timestamp.
function(update_file path content)
    set(old_content "")
    if(EXISTS "${path}")
        file(READ "${path}" old_content)
    endif()
    if(NOT old_content STREQUAL content)
        file(WRITE "${path}" "${content}")
    endif()
endfunction()

# Creates a file called CMakeDeps.cmake next to the CMakeLists.txt with
# the list of dependencies in it - this file should be treated as part of 
# CMakeLists.txt (source controlled, etc.).
function(update_deps_file)
    set(deps_file "CMakeDeps.cmake")
    # Normalize the list so it's the same on every machine
    foreach(dep ${ARGV})
        get_filename_component(dep "${dep}" ABSOLUTE)
        file(RELATIVE_PATH rel_dep ${CMAKE_CURRENT_SOURCE_DIR} ${dep})
        list(APPEND rel_deps ${rel_dep})
    endforeach()
    list(REMOVE_DUPLICATES rel_deps)
    list(SORT rel_deps)
    # Build the content
    set(content "# generated by make process\n")
    foreach(dep IN LISTS rel_deps)
        string(APPEND content "# ${dep}\n")
    endforeach()
    # Update the deps file
    update_file("${deps_file}" "${content}")
    # Include the file so it's tracked as a generation dependency; we don't
    # need the content.
    include(${deps_file})
endfunction()

function(write_user_file prjname)
    set(user_file "${CMAKE_CURRENT_BINARY_DIR}/${prjname}.vcxproj.user")
    file(WRITE ${user_file} [=[
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" 
        xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
]=])
    foreach(cfgname ${CMAKE_CONFIGURATION_TYPES})
        if(${cfgname} STREQUAL Release)
            set(libpath "lib")
        else()
            set(libpath "${cfgname}/lib")
        endif()
        file(APPEND ${user_file} [=[
    <PropertyGroup Condition="'$(Configuration)|$(Platform)'==']=] "${cfgname}" [=[|x64'">
        <LocalDebuggerWorkingDirectory>$(TargetDir)</LocalDebuggerWorkingDirectory>
        <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
        <VcpkgLibPath>]=] "${libpath}" [=[</VcpkgLibPath>
    </PropertyGroup>
]=])
    endforeach()
    file(APPEND ${user_file} [=[
</Project>
]=])
endfunction()

function(install_archive_pdb tgt dstdir)
    if(BUILD_SHARED_LIBS)
        install(FILES "$<TARGET_PDB_FILE:${tgt}>" DESTINATION bin)
    else()
        # Special handling required to get PDBs of static libraries installed.
        # I would hope that there's a better way to do this, but I don't know 
        # what it may be...
        foreach(cfg ${CMAKE_CONFIGURATION_TYPES})
            install(FILES 
                "${CMAKE_CURRENT_BINARY_DIR}/${tgt}.dir/${cfg}/${tgt}.pdb" 
                DESTINATION ${dstdir} 
                CONFIGURATIONS ${cfg})
        endforeach()
    endif()
endfunction()

function(set_pch tgt srcdir)
    if(MSVC AND EXISTS "${srcdir}/pch.h")
        # use pch.cpp to create precompiled header
        set_property(SOURCE "${srcdir}/pch.cpp" 
            APPEND PROPERTY COMPILE_FLAGS "/Ycpch.h")
        # use pch.h as precompiled header
        set_property(TARGET ${tgt} APPEND PROPERTY COMPILE_FLAGS "/Yupch.h")
    endif()
endfunction()

function(add_exec_project tgt srcdir)
    file(GLOB_RECURSE sources 
        LIST_DIRECTORIES false ${srcdir}/*.h ${srcdir}/*.cpp)
    list(APPEND deps ${sources})
    set(deps ${deps} PARENT_SCOPE)
    add_executable(${tgt} ${sources})
    set_pch(${tgt} ${srcdir})
	if(MSVC)
		set_target_properties(${tgt} PROPERTIES LINK_FLAGS /Debug)
	endif()
    foreach(var ${libnames})
        get_filename_component(libname "${var}" NAME)
        target_link_libraries(${tgt} ${libname})
    endforeach()
	if(CMAKE_COMPILER_IS_GNUCXX)
        # required for #include <experimental/filesystem>
		target_link_libraries(${tgt} "stdc++fs")
    elseif(CMAKE_CXX_COMPILER_ID STREQUAL Clang)
		target_link_libraries(${tgt} "stdc++fs")
    endif()
    write_user_file(${tgt})
endfunction()

function(add_lib_project tgt srcdir)
    file(GLOB_RECURSE sources LIST_DIRECTORIES false ${srcdir}/*)
    list(APPEND deps ${sources})
    set(deps ${deps} PARENT_SCOPE)
    set(cpps ${sources})
    list(FILTER cpps INCLUDE REGEX ".*\.cpp$")
    list(LENGTH cpps cpps)
    if(cpps)
        add_library(${tgt} ${sources})
        target_compile_definitions(${tgt} PRIVATE DIM_LIB_SOURCE)
        list(APPEND libnames ${tgt})
        set(libnames ${libnames} PARENT_SCOPE)

        if(INSTALL_LIBS)
            install(TARGETS ${tgt}
                ARCHIVE DESTINATION lib
                RUNTIME DESTINATION bin)
            install_archive_pdb(${tgt} lib)
        endif()
    else()
        add_custom_target(${tgt} SOURCES ${sources})
        set_target_properties(${tgt} PROPERTIES EXCLUDE_FROM_ALL false)
    endif()
    set_target_properties(${tgt} PROPERTIES FOLDER libs)
    set_pch(${tgt} ${srcdir})
    if(INSTALL_LIBS)
        file(GLOB incls LIST_DIRECTORIES false 
            RELATIVE "${srcdir}" "${srcdir}/*.h")
        foreach(var ${incls})
            get_filename_component(name "${var}" NAME)
            if(NOT name MATCHES ".*int\.h")
                install(FILES "${srcdir}/${var}" DESTINATION include/${tgt})
            endif()
        endforeach()
    endif()
    write_user_file(${tgt})
endfunction()


#############################################################################
#
#   Main
#
####

# get name of project from containing directory
get_filename_component(prjname "${CMAKE_CURRENT_SOURCE_DIR}" NAME)
project(${prjname})

get_property(parent DIRECTORY PROPERTY PARENT_DIRECTORY)
if("${parent}" STREQUAL "")
    set(ROOT_PROJECT true)
else()
    set(ROOT_PROJECT false)
endif()

# In order to make a copy of the solution to the source root (where it's 
# required to be for the github integration) we need to copy - and tweak - it
# post generation. But cmake doesn't allow for post generation hooks, so we 
# launch another instance of cmake and then transform and copy the solution 
# file after that instance returns.
if(ROOT_PROJECT AND NOT RECURSIVE_GENERATE)
    message(STATUS "Recursive generate started")
    execute_process(
        COMMAND ${CMAKE_COMMAND} 
            -G "${CMAKE_GENERATOR}"
            -T "${CMAKE_GENERATOR_TOOLSET}"
            -A "${CMAKE_GENERATOR_PLATFORM}"
            -DRECURSIVE_GENERATE:BOOL=ON 
            -DLINK_STATIC_RUNTIME:BOOL=${LINK_STATIC_RUNTIME}
            -DBUILD_SHARED_LIBS:BOOL=${BUILD_SHARED_LIBS}
            -DBUILD_UNICODE:BOOL=${BUILD_UNICODE}
            ${CMAKE_SOURCE_DIR}
    )
    message(STATUS "Recursive generate done")

    set(sln_binpath ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.sln)
    if(EXISTS ${sln_binpath})
        # Load solution file from bin-dir and change the relative references 
        # to project files so that the in memory copy is as if it had been 
        # built in the source dir.
        file(RELATIVE_PATH prefix 
            "${CMAKE_CURRENT_SOURCE_DIR}"
            "${CMAKE_CURRENT_BINARY_DIR}")
        file(READ ${sln_binpath} sln_content)
        string(REGEX REPLACE 
            "\"([^\"]+).vcxproj\""
            "\"${prefix}/\\1.vcxproj\"" 
            sln_content
            "${sln_content}")

        # Compare the updated contents with the existing source path sln, if it
        # exists and is the same we don't want to disturb VS by touching it.
        set(sln_srcpath ${CMAKE_CURRENT_SOURCE_DIR}/${PROJECT_NAME}.sln)
        update_file("${sln_srcpath}" "${sln_content}")
    endif()

    # Fallthrough so that (in addition to a duplicate generate :P) any 
    # --build or --install gets to run with all the facts.
endif()

set_property(GLOBAL PROPERTY USE_FOLDERS ON)
set_property(GLOBAL PROPERTY PREDEFINED_TARGETS_FOLDER cmake)

set(CMAKE_CONFIGURATION_TYPES Debug Release)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${CMAKE_BINARY_DIR}/bin)

if(NOT ROOT_PROJECT)
    set_property(DIRECTORY "${parent}" APPEND PROPERTY INCLUDE_DIRECTORIES 
        "${CMAKE_CURRENT_SOURCE_DIR}/libs")
endif()
include_directories(libs)

if(MSVC)
    # "/utf-8" - sets source code character set to utf-8
    # "/W4" - warning level 4
    # "/WX" - treat warnings as errors
    # "/Zi" - debug info format - defaults to no info
    # "/std:c++latest" - allow constructs still pending standardization
    # "/Zc:inline" - all inline functions must have definition available
    # "/Zc:rvalueCast" - enforce type conversion rules
    # "/Zc:strictStrings" - disable string literal type conversion to non-const
    # "/GR-" (UNUSED) - disable RTTI
    # "/EHsc" - exceptions from c++ only (not from structure or "C")
    # "/GF" - string pooling
    set(CMAKE_CXX_FLAGS "\
        /utf-8 /W4 /WX /Zi \
        /std:c++latest /Zc:inline /Zc:rvalueCast /Zc:strictStrings \
        /EHsc /GF")
    if(NOT MSVC_VERSION LESS 2000)
        # /permissive-  // reject non-conforming backward compatibilitisms
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /permissive-")
    endif()

    # "/Od" - disables optimization
    # "/RTC1" - runtime checks (stack frame over/under run and uninit var use)
    set(CMAKE_CXX_FLAGS_DEBUG "/Od /RTC1")
    if(LINK_STATIC_RUNTIME)
        # "/MTd" - multithread debug static runtime
        set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MTd")
    else()
        # "/MDd" - multithread debug dll runtime
        set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MDd")
    endif()
    
    # "/O2" - maximize speed
    set(CMAKE_CXX_FLAGS_RELEASE "/DNDEBUG /O2")
    if(LINK_STATIC_RUNTIME)
        # "/MT" - multithread release static runtime
        set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MT")
    else()
        # "/MD" - multithread release dll runtime
        set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MD")
    endif()

    set_property(SOURCE "pch.cpp" APPEND PROPERTY COMPILE_FLAGS "/Ycpch.h")
elseif(CMAKE_CXX_COMPILER_ID STREQUAL Clang)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++1z")
endif()

if(BUILD_UNICODE)
    add_definitions(/D_UNICODE)
endif()

# set list of defines that need to go in config.h
if(BUILD_SHARED_LIBS)
    list(APPEND config_defines DIM_LIB_DYN_LINK)
endif()
if(WINDOWS_STORE)
    list(APPEND config_defines DIM_LIB_WINAPI_FAMILY_APP)
endif()
foreach(var ${config_defines})
    add_definitions(/D${var})
endforeach()

# Setting source_group to a single space is weird and relys on Visual Studio 
# treating it as no group, ideally we'd set it to the empty string to mean 
# no group, but - just for regexs (bug?) - that causes cmake to use defaults.
source_group(" " REGULAR_EXPRESSION ".*")
source_group("docs" REGULAR_EXPRESSION "docs/.*")

if(ROOT_PROJECT)
    # vendor dependencies
    file(GLOB allnames vendor/*)
    foreach(var ${allnames})
        if(IS_DIRECTORY "${var}")
            list(APPEND deps "${var}")
            get_filename_component(prjname "${var}" NAME)
            if(EXISTS "${var}/CMakeLists.txt")
                add_subdirectory("${var}")
            endif()
        endif()
    endforeach()
endif()

# lib targets
file(GLOB allnames libs/*)
foreach(var ${allnames})
    if(IS_DIRECTORY "${var}")
        get_filename_component(prjname "${var}" NAME)
        if(NOT prjname STREQUAL ${PROJECT_NAME})
            set(prjname ${PROJECT_NAME}-${prjname})
        endif()
        add_lib_project(${prjname} "${var}")
    endif()
endforeach()

if(NOT ROOT_PROJECT)
    set(deps ${deps} PARENT_SCOPE)
    set(libnames ${libnames} PARENT_SCOPE)
    return()
endif()

# file targets
file(GLOB sources LIST_DIRECTORIES false 
    LICENSE
    .clang-format
    .travis.yml
    appveyor.yml
    *.md
    configure.bat
    docs/*)
list(APPEND deps ${sources})
add_custom_target(about SOURCES ${sources})
set_target_properties(about PROPERTIES 
    FOLDER files
    EXCLUDE_FROM_ALL false)

# tool targets
file(GLOB allnames tools/*)
foreach(var ${allnames})
    if(IS_DIRECTORY "${var}")
        get_filename_component(prjname "${var}" NAME)
        add_exec_project(${prjname} "${var}")
        set_target_properties(${prjname} PROPERTIES FOLDER tools)
        if(INSTALL_TOOLS)
            install(TARGETS ${prjname} RUNTIME DESTINATION bin)
        endif()
    endif()
endforeach()

# test targets
file(GLOB allnames tests/*)
foreach(var ${allnames})
    if(IS_DIRECTORY "${var}")
        get_filename_component(prjname "${var}" NAME)
        add_exec_project(${prjname} "${var}")
        set_target_properties(${prjname} PROPERTIES FOLDER tests)
        add_test(NAME ${prjname} COMMAND ${prjname} --test)
        if(INSTALL_TESTS)
            install(TARGETS ${prjname} RUNTIME DESTINATION bin)
        endif()
    endif()
endforeach()

# update deps file
update_deps_file(${deps})

# Create modifed config.h to reflect build defines
set(cfgname "libs/${PROJECT_NAME}/config.h")
get_filename_component(path ${cfgname} ABSOLUTE)
if(EXISTS "${path}")
    file(READ "${path}" content)
    foreach(val ${config_defines})
        string(REGEX REPLACE 
            "\n//#define ${val}" "\n#define ${val}" 
            content "${content}")
    endforeach()
    update_file("${CMAKE_CURRENT_BINARY_DIR}/${cfgname}" "${content}")

    if(INSTALL_LIBS)
        install(FILES "${CMAKE_CURRENT_BINARY_DIR}/${cfgname}" 
            DESTINATION include/${PROJECT_NAME})
    endif()
endif()
