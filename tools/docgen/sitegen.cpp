// Copyright Glen Knowles 2020 - 2026.
// Distributed under the Boost Software License, Version 1.0.
//
// sitegen.cpp - docgen
#include "pch.h"
#pragma hdrstop

using namespace std;
using namespace Dim;


/****************************************************************************
*
*   Declarations
*
***/

namespace {

struct CmdOpts {
    string cfgfile;

    CmdOpts();
};

struct TocEntry {
    size_t pos;
    unsigned depth;
    std::string name;
    std::string link;
};

struct GenPageInfo {
    Config * out;
    const Version & ver;
    const Page & page;
    function<void()> fn;

    string fname;
    string content;
};

}


/****************************************************************************
*
*   Forward declarations
*
***/

static void genSite(Config * out, unsigned phase = 0);


/****************************************************************************
*
*   Variables
*
***/

static CmdOpts s_opts;


/****************************************************************************
*
*   Generate site files
*
***/

//===========================================================================
static void genFileHeader(CharBuf * out, const Path & fname) {
    out->append(fname).pushBack('\n')
        .append("Generated by docgen ").append(toString(appVersion()))
            .pushBack('\n');
}

//===========================================================================
static void genHtmlHeader(CharBuf * out, const Path & fname) {
    out->append("<!DOCTYPE html>\n<!--\n");
    genFileHeader(out, fname);
    out->append("-->\n");
}

//===========================================================================
static void genFaviconLink(
    IXBuilder * out,
    const Path & fname,
    const Config & cfg
) {
    if (cfg.siteFavicon.empty()) {
        fname.size();
    } else {
        Path href("favicon.ico");
        if (cfg.tag.empty())
            href.relative(fname.parentPath());
        *out << start("link")
            << attr("rel", "icon")
            << attr("type", "image/x-icon")
            << attr("href", href)
            << end;
    }
}

//===========================================================================
string genAutoId(string_view title) {
    constexpr unsigned kStartChar = 1;
    constexpr unsigned kChar = 2;

    struct CharDefs {
        uint8_t flags[256];
    };
    static const CharDefs s_defs = [](){
        CharDefs out = {};
        for (unsigned char ch
            : "ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
        ) {
            out.flags[ch] |= kStartChar | kChar;
        }
        for (unsigned char ch : "0123456789") {
            out.flags[ch] |= kChar;
        }
        return out;
    }();

    string out;
    if (title.empty())
        return out;

    // In the title, reduce runs of illegal chars (and dashes) to a single '-'.
    bool multisep = false;
    if (~s_defs.flags[(unsigned char) title[0]] & kStartChar) {
        out += '-';
        multisep = true;
    }
    for (unsigned char ch : title) {
        if (~s_defs.flags[ch] & kChar) {
            if (!multisep) {
                out += '-';
                multisep = true;
            }
            continue;
        }
        out += ch;
        multisep = false;
    }

    toLower(out.data());
    return out;
}

//===========================================================================
static vector<TocEntry> createToc(string * content) {
    static const regex s_tocEntry(
        //           depth            id        name
        R"regex(<[hH]([1-6])(?:|\sid="([^"]+)")>(.*)</[hH]\1>)regex",
        regex::optimize
    );

    unordered_map<string, int> ids;
    vector<TocEntry> out;
    cmatch m;
    size_t pos = 0;
    int h1Count = 0;
    for (;;) {
        if (!regex_search(content->data() + pos, m, s_tocEntry))
            break;
        auto & te = out.emplace_back();
        te.pos = pos + m.position();
        te.depth = content->data()[pos + m.position(1)] - '0';
        if (te.depth == 1)
            h1Count += 1;
        te.name = m.str(3);

        if (m[2].matched) {
            te.link = genAutoId(m.str(2));
        } else {
            te.link = genAutoId(te.name);
        }
        auto num = ids[te.link] += 1;
        if (num > 1) {
            te.link += "--";
            te.link += toChars(num).view();
        }
        if (m[2].matched) {
            auto olen = m.length(2);
            content->replace(pos + m.position(2), olen, te.link);
            pos += te.link.size() - olen;
        } else {
            auto tmp = string(" id=\"") + te.link + '"';
            content->insert(pos + m.position(1) + 1, tmp);
            pos += tmp.size();
        }

        pos += m.position() + m.length();
    }

    // If there's only one H1 and it's the first H*, remove it from the TOC
    // and bump up all other headers by one.
    if (h1Count == 1 && out[0].depth == 1) {
        out.erase(out.begin());
        for (auto&& te : out)
            te.depth -= 1;
    }

    return out;
}

//===========================================================================
static void updateXrefLinks(string * content, const Layout & layout) {
    static const regex s_xrefLink(
        //               ref
        R"regex(<a href="([^#"]+)[^"]*">)regex",
        regex::optimize
    );

    unordered_map<string_view, string> mapping;
    for (auto&& page : layout.pages) {
        mapping[page.xrefFile] = page.urlSegment + ".html";
    }

    cmatch m;
    size_t pos = 0;
    for (;;) {
        if (!regex_search(content->data() + pos, m, s_xrefLink))
            break;
        if (m[1].matched) {
            auto ref = m.str(1);
            auto map = mapping.find(ref);
            if (map != mapping.end()) {
                content->replace(pos + m.position(1), ref.size(), map->second);
                pos += map->second.size() - ref.size();
            }
        }
        pos += m.position() + m.length();
    }
}

//===========================================================================
static void addFontAwesomeHead(IXBuilder * out) {
    auto & bld = *out;
    bld.start("link")
        .attr("rel", "stylesheet")
        .attr("href", "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/"
            "4.7.0/css/font-awesome.min.css")
        .end();
}

//===========================================================================
static void addPrismJsHead(IXBuilder * out, const Page & page) {
    auto & bld = *out;
    bld.start("link")
        .attr("rel", "stylesheet")
        .attr("href", page.urlRoot / "vendor" / "prismjs@1.30.0" / "prism.css")
        .end();
    bld.start("script")
        .attr("src", page.urlRoot / "vendor" / "prismjs@1.30.0" / "prism.js")
        .text("") // script elements must have separate closing tag (no '/>')
        .end();
}

//===========================================================================
static void addHighlightJsHead(IXBuilder * out, Page::Type type) {
    auto & bld = *out;
    bld.start("link")
        .attr("rel", "stylesheet")
        .attr("href", "https://cdnjs.cloudflare.com/ajax/libs/"
            "highlight.js/11.9.0/styles/default.min.css")
        .end();
    bld.start("script")
        .attr("src", "https://cdnjs.cloudflare.com/ajax/libs/"
            "highlight.js/11.9.0/highlight.min.js")
        .text("")
        .end();
    bld.start("script")
        .text(1 + R"(
document.addEventListener('DOMContentLoaded', (event) => {
  document.querySelectorAll('pre code').forEach((block) => {
    try {
        var lang = block.parentElement.lang.toLowerCase();
        if (lang == 'shell session') {
            lang = 'console';
        }
        var code = hljs.highlight(block.textContent, {language: lang});
        block.className += 'hljs';
        block.innerHTML = code.value;
    } catch (e) {
    }
  });
});
)")
        .end();
}

//===========================================================================
static void addBootstrapHead(IXBuilder * out) {
    auto & bld = *out;
    bld.start("meta")
        .attr("name", "viewport")
        .attr("content", "width=device-width, initial-scale=1, "
            "shrink-to-fit=no")
        .end();
    bld.start("link")
        .attr("rel", "stylesheet")
        .attr("href", "https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/"
            "css/bootstrap.min.css")
        .attr("integrity",
"sha384-xOolHFLEh07PJGoPkLv1IbcEPTNtaed2xpHsD9ESMhqIYd0nLMwNLD69Npy4HI+N")
        .attr("crossorigin", "anonymous")
        .end();
}

//===========================================================================
static void addBootstrapBody(IXBuilder * out) {
    auto & bld = *out;
    bld.start("script")
        .attr("src", "https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/"
            "jquery.slim.min.js")
        .attr("integrity",
"sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj")
        .attr("crossorigin", "anonymous")
        .text("")
        .end();
    bld.start("script")
        .attr("src", "https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/"
            "popper.min.js")
        .attr("integrity",
"sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN")
        .attr("crossorigin", "anonymous")
        .text("")
        .end();
    bld.start("script")
        .attr("src", "https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/"
            "bootstrap.min.js")
        .attr("integrity",
"sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+")
        .attr("crossorigin", "anonymous")
        .text("")
        .end();
}

//===========================================================================
static void addBadgePrelim(IXBuilder * out) {
    out->text(" ")
        .start("span")
            .attr("class", "badge prelim-badge")
            .text("Prelim")
            .end();
}

//===========================================================================
static void addBadgeOld(IXBuilder * out) {
    out->text(" ")
        .start("span")
            .attr("class", "badge old-badge")
            .text("Old")
            .end();
}

//===========================================================================
static void addNavbar(
    IXBuilder * out,
    const Config & cfg,
    const Version & version,
    const Layout & layout,
    const Page & page
) {
    const char kBgClass[] = "bg-primary";
    const enum { kDark, kLight } kSchemaType = kDark;

    auto & bld = *out;
    bld.start("nav")
        .startAttr("class")
            .text("navbar navbar-expand-sm sticky-top ")
            .text(kBgClass).text(" ")
            .text(kSchemaType == kDark ? "navbar-dark" : "navbar-light")
            .endAttr()
        .start("a")
            .attr("class", "navbar-brand fw-bolder")
            .attr("href", page.urlRoot)
            .text(cfg.siteName)
            .end()
        .start("button")
            .attr("class", "navbar-toggler")
            .attr("type", "button")
            .attr("data-toggle", "collapse")
            .attr("data-target", "#navbarNavAltMarkup")
            .attr("aria-controls", "navbarNavAltMarkup")
            .attr("aria-expanded", "false")
            .attr("aria-label", "Toggle navigation")
            .start("span")
                .attr("class", "navbar-toggler-icon")
                .text("").end()
            .end()
        .start("div")
            .attr("class", "collapse navbar-collapse")
            .attr("id", "navbarNavAltMarkup");

    // Page from layout
    bld.start("div")
        .attr("class", "navbar-nav mr-auto");
    for (auto&& pg : layout.pages) {
        auto url = page.urlRoot / version.tag / pg.urlSegment + ".html";
        if (pg.rootPage == page.rootPage) {
            bld.start("a")
                .attr("class", "nav-link active")
                .attr("href", url)
                .text(pg.name)
                .text(" ")
                .start("span")
                .attr("class", "sr-only")
                .text("(current)")
                .end()
                .end();
        } else {
            bld.start("a")
                .attr("class", "nav-link")
                .attr("href", url)
                .text(pg.name)
                .end();
        }
    }
    bld.end(); // div.navbar-nav

    // Version links
    bool beforeDefault = true;
    bool afterDefault = false;
    for (auto&& ver : cfg.versions) {
        if (ver.defaultSource)
            beforeDefault = false;
        if (ver.tag == version.tag)
            break;
        if (ver.defaultSource)
            afterDefault = true;
    }
    bld.start("div")
        .attr("class", "navbar-nav")
        .start("div")
            .attr("class", "nav-item dropdown")
            .start("a")
                .attr("class", "nav-link dropdown-toggle")
                .attr("href", "#")
                .attr("id", "navbarDropdown")
                .attr("role", "button")
                .attr("data-toggle", "dropdown")
                .attr("data-reference", "parent")
                .attr("aria-haspopup", "true")
                .attr("aria-expanded", "false")
                .attr("title", "Version")
                .text(version.name);
    if (beforeDefault)
        addBadgePrelim(&bld);
    if (afterDefault)
        addBadgeOld(&bld);
    bld.end()
        .start("div")
            .attr("class", "dropdown-menu dropdown-menu-md-right")
            .attr("aria-labelledby", "navbarDropdown");
    beforeDefault = true;
    afterDefault = false;
    for (auto&& ver : cfg.versions) {
        bld.start("a");
        if (ver.tag != version.tag) {
            bld.attr("class", "dropdown-item");
        } else {
            bld.attr("class", "dropdown-item active");
        }
        if (ver.urlSegments.contains(page.urlSegment)) {
            bld.attr(
                "href",
                page.urlRoot / ver.tag / page.urlSegment + ".html"
            );
        } else {
            bld.attr("href", page.urlRoot / ver.tag / "index.html");
        }
        if (ver.defaultSource)
            beforeDefault = false;
        bld.text(ver.name);
        if (beforeDefault)
            addBadgePrelim(&bld);
        if (afterDefault)
            addBadgeOld(&bld);
        bld.end();
        if (ver.defaultSource)
            afterDefault = true;
    }
    bld.end() // div.dropdown-menu
        .end(); // div.nav-item

    // GitHub link
    if (cfg.github) {
        bld.start("a")
            .attr("class", "nav-link py-0 px-3")
            .attr("href", cfg.repoUrl)
            .attr("style", "font-size: 24px;")
            .start("i")
                .attr("style", "width: 24px")
                .attr("class", "fa fa-github")
                .attr("title", "View Source")
                .text("").end()
            .end();
    }

    bld.end(); // div.navbar-nav
    bld.end(); // div#navbarNavAltMarkup
    bld.end(); // nav
}

//===========================================================================
static void addSideStart(IXBuilder * out) {
    auto & bld = *out;
    bld.start("div")
        .attr("class", "d-none d-lg-block col-lg-auto")
        .attr("style", "margin-top: 1.25rem;")
        .start("nav")
        .attr(
            "class",
            "nav sticky-top d-print-none d-none d-lg-flex flex-column"
        )
        .attr("style", "scrollbar-gutter: stable")
        .attr("id", "toc")
        .start("div")
        .attr("style", "display: grid; grid-template-columns: 1fr;");
}

//===========================================================================
static void addSideEnd(IXBuilder * out) {
    auto & bld = *out;
    bld.end()  // div.grid
        .end() // nav
        .end(); // div.d-lg-block
}

//===========================================================================
static void addTocEntries(
    IXBuilder * out,
    const vector<TocEntry> & entries,
    bool foreground
) {
    auto & bld = *out;
    bld.start("div")
        << attr("style") << "grid-row-start: 1; grid-column-start: 1;"
        << endAttr;
    if (!foreground)
        bld << attr("class", "invisible nav-shadow");
    for (auto&& ent : entries) {
        if (ent.depth >= 1 && ent.depth <= 3) {
            bld.start("a") << attr("class");
            bld << "nav-link toc-" << ent.depth << endAttr;
            if (foreground)
                bld << attr("href") << "#" << ent.link << endAttr;
            bld << "";
            bld.addRaw(ent.name);
            bld.end();
        }
    }
    bld.end();
}

//===========================================================================
static void addToc(IXBuilder * out, const vector<TocEntry> & entries) {
    addSideStart(out);
    addTocEntries(out, entries, false);
    addTocEntries(out, entries, true);
    addSideEnd(out);
}

//===========================================================================
static void addGroupTocEntries(
    XBuilder * out,
    const Page & page,
    const Layout & layout,
    const Version & version,
    bool foreground
) {
    auto & bld = *out;
    bld.start("div")
        << attr("style") << "grid-row-start: 1; grid-column-start: 1;"
        << endAttr;
    if (!foreground)
        bld << attr("class", "invisible nav-shadow");
    auto i = layout.pages.begin();
    advance(i, page.rootPage);
    auto & rootPage = *i;
    for (auto&& pg : rootPage.pages) {
        if (!pg.file.empty()) {
            bld.start("a") << attr("class") << "nav-link";
        } else {
            bld.start("span") << attr("class") << "nav-title";
        }
        bld << " toc-" << pg.depth;
        if (&pg == &page)
            bld << " active";
        bld << endAttr;
        if (!pg.file.empty()) {
            bld << attr("href")
                << pg.urlRoot / version.tag / pg.urlSegment + ".html"
                << endAttr;
        }
        bld << "";
        bld.addRaw(pg.name);
        bld.end();
    }

    bld.end();
}

//===========================================================================
static void addGroupToc(
    XBuilder * out,
    const Page & page,
    const Layout & layout,
    const Version & version
) {
    if (!page.depth)
        return;
    addSideStart(out);
    addGroupTocEntries(out, page, layout, version, false);
    addGroupTocEntries(out, page, layout, version, true);
    addSideEnd(out);
}

//===========================================================================
static void addBodyCol(
    IXBuilder * out,
    const Page & page,
    const string & content
) {
    auto & bld = *out;
    bld.start("div")
        .attr("class", "col col-lg-9 mt-3")
        .attr("role", "main");
    if (page.type == Page::kCpp) {
        bld.start("h1")
            .attr("id", genAutoId(page.name))
            .text(page.name)
            .end();
        bld.elem("br");
        bld.start("pre")
                .attr("lang", "C++")
                .attr("class", "line-numbers")
            .start("code")
                .attr("class", "language-cpp")
                .text(content)
                .end()
            .end(); // pre
    } else {
        bld.text("");
        bld.addRaw(content);
    }
    bld.end();
}

//===========================================================================
static CharBuf processPageContent(
    GenPageInfo * info,
    string && content,
    const Path & fname
) {
    auto cfg = info->ver.cfg ? info->ver.cfg.get() : info->out;
    string layname = info->ver.layout.empty() ? "default" : info->ver.layout;
    auto & layout = cfg->layouts.find(layname)->second;
    auto pglayname = info->page.pageLayout;
    auto & pglay = cfg->pageLayouts.find(pglayname)->second;

    updateXrefLinks(&content, layout);
    auto toc = createToc(&content);

    CharBuf html;
    genHtmlHeader(&html, fname);
    XBuilder bld(&html);
    bld.start("html")
        .attr("lang", "en")
        .start("head")
        .start("meta").attr("charset", "utf-8").end();
    bld.elem("title", info->page.name + " - " + info->out->siteName);
    genFaviconLink(&bld, fname, *cfg);
    if (info->page.type == Page::kCpp) {
        addPrismJsHead(&bld, info->page);
    } else {
        addHighlightJsHead(&bld, info->page.type);
    }
    addBootstrapHead(&bld);
    addFontAwesomeHead(&bld);
    for (auto&& f : {"docgen.css", "asciidoc.css", "prism.css"}) {
        bld.start("link")
            .attr("rel", "stylesheet")
            .attr("href", info->page.urlRoot / "code" / f)
            .end();
    }
    bld.elem("script", 1 + R"(
document.addEventListener('DOMContentLoaded', (event) => {
  document.querySelectorAll('table.tableblock').forEach((tab) => {
    tab.classList.add('table', 'table-sm', 'table-striped', 'table-hover')
  });
  /*
  document.querySelectorAll('div[role="main"] [id]').forEach((h) => {
    let par = h.closest('div')
    let id = h.id
    h.removeAttribute('id')
    par.setAttribute('id', id)
  });
  */
});
)");
    bld.end(); // </head>

    bld.start("body");
    if (!pglay.scrollSpy.empty()) {
        bld.attr("data-spy", "scroll")
            .attr("data-target", pglay.scrollSpy)
            .attr("data-smooth-scroll", "false");
    }
    bld.text("\n");
    addNavbar(&bld, *info->out, info->ver, layout, info->page);
    bld.start("div")
        .attr("class", "container")
        .start("div")
            .attr("class", "row flex-nowrap");
    for (auto&& col : pglay.columns) {
        switch (col.content) {
        case Column::kContentInvalid:
            assert(!"INTERNAL: Invalid column content");
            break;
        case Column::kContentBody:
            addBodyCol(&bld, info->page, content);
            break;
        case Column::kContentGroupToc:
            addGroupToc(&bld, info->page, layout, info->ver);
            break;
        case Column::kContentToc:
            addToc(&bld, toc);
            break;
        }
    }
    bld.end(); // div.row
    bld.end(); // div.container-fluid

    addBootstrapBody(&bld);
    bld.end() // </body>
        .end(); // </html>
    return html;
}

//===========================================================================
static void genPage(GenPageInfo * info, unsigned phase = 0) {
    Finally fin([info] () { info->fn(); });

    if (appStopping())
        return;

    auto cfg = info->ver.cfg ? info->ver.cfg.get() : info->out;
    string layname = info->ver.layout.empty() ? "default" : info->ver.layout;

    unsigned what = 0;

    if (phase == what++) {
        // Load page markup.
        auto pglayname = info->page.pageLayout;
        auto pglay = cfg->pageLayouts.find(pglayname);
        if (pglay == cfg->pageLayouts.end()) {
            logMsgError() << "Tag '" << info->ver.tag << "': page layout '"
                << pglayname << "' not defined.";
            return appSignalShutdown(EX_DATAERR);
        }
        loadContent(
            [info, what](auto && content) {
                info->content = move(content);
                genPage(info, what);
            },
            *info->out,
            info->ver.tag,
            info->page.file
        );
        return fin.release();
    }
    if (info->content.empty()) {
        logMsgError() << info->page.file << ", tag '" << info->ver.tag
            << "': unable to load content";
        return appSignalShutdown(EX_DATAERR);
    }
    if (phase == what++) {
        // Save markup to temporary file.
        auto p = Path(info->page.file);
        fileTempName(&p, p.extension());
        info->fname = p.str();
        writeContent(
            [info, what]() { genPage(info, what); },
            p,
            info->content
        );
        return fin.release();
    }
    if (phase == what++) {
        // Apply patch from config file
        if (!info->page.patch.empty()) {
            auto cmdline = Cli::toCmdlineL(
                "patch",
                "-r",
                info->fname + "#",
                info->fname
            );
            execTool(
                [info, what](auto && res) {
                    fileRemove(info->fname + "#");
                    if (res.output.empty())
                        appSignalShutdown(EX_IOERR);
                    genPage(info, what);
                },
                cmdline,
                info->page.file + ", tag '" + info->ver.tag + "'",
                { .stdinData = info->page.patch }
            );
            return fin.release();
        }

        // No patch, continue to next phase.
        phase = what;
    }
    if (phase == what++) {
        // Convert markup into HTML fragment.
        auto cmdline = Cli::toCmdlineL("github-markup.bat", info->fname);
        execTool(
            [info, what](auto && res) {
                fileRemove(info->fname);
                info->content = move(res.output);
                genPage(info, what);
            },
            cmdline,
            info->page.file + ", tag '" + info->ver.tag + "'"
        );
        return fin.release();
    }
    if (phase == what++) {
        // Update HTML fragment, embed into HTML page, and add to site output
        // files.
        auto fname = Path(info->ver.tag) / info->page.urlSegment + ".html";
        auto html = processPageContent(info, move(info->content), fname);
        if (!addOutput(info->out, fname, move(html)))
            return;

        info->fn();
        return fin.release();
    }

    assert(!"unknown phase");
}

//===========================================================================
[[maybe_unused]]
static bool genEmbeddedStatics(Config * out) {
    ResFileMap files;
    if (!files.parse(resWebSiteContent())) {
        logMsgError() << "INTERNAL ERROR: loading predefined site files";
        appSignalShutdown(EX_SOFTWARE);
        return false;
    }
    unordered_map<string, string> vars;
    vars["version"] = toString(appVersion());
    for (auto&& f : files) {
        CharBuf buf(f.second.content);
        if (!addOutput(out, Path(f.first).relative("/"), move(buf)))
            return false;
    }
    return true;
}

//===========================================================================
static bool genRedirect(
    Config * out,
    string_view outputFile,
    string_view targetUrl
) {
    auto fname = Path(outputFile);
    CharBuf html;
    genHtmlHeader(&html, fname);
    XBuilder bld(&html);
    bld << start("html")
        << start("head")
            << start("meta") << attr("charset", "utf-8") << end
            << start("meta")
                << attr("http-equiv", "refresh")
                << attr("content")
                    << "0; url='" << targetUrl << "'" << endAttr
                << end;
    genFaviconLink(&bld, fname, *out);
    bld << end
        << end;

    return addOutput(out, fname, move(html));
}

//===========================================================================
static bool addUrlSegments(Version * out, const list<Page> & pages) {
    for (auto&& page : pages) {
        if (!page.file.empty()) {
            if (!out->urlSegments.insert(page.urlSegment).second) {
                logMsgError() << "Tag '" << out->tag << "': url segment '"
                    << page.urlSegment << "' multiply defined.";
                appSignalShutdown(EX_DATAERR);
                return false;
            }
        }
        if (!addUrlSegments(out, page.pages))
            return false;
    }
    return true;
}

//===========================================================================
static bool genRedirects(Config * out) {
    for (auto&& ver : out->versions) {
        auto spec = ver.cfg ? ver.cfg.get() : out;
        string layname = ver.layout.empty() ? "default" : ver.layout;
        auto layout = spec->layouts.find(layname);

        if (layout == spec->layouts.end()) {
            logMsgError() << "Tag '" << ver.tag << "': layout '" << layname
                << "' not defined.";
            appSignalShutdown(EX_DATAERR);
            return false;
        }

        // Generate infrastructure files for version
        auto defPage = layout->second.pages.begin();
        if (layout->second.defPage != -1)
            advance(defPage, layout->second.defPage);
        auto & url = defPage->urlSegment;
        if (!genRedirect(out, ver.tag + "/index.html", url + ".html"))
            return false;
        if (ver.defaultSource) {
            if (!genRedirect(out, "index.html", ver.tag + "/index.html"))
                return false;
        }

        // Populate list of URLs for version
        addUrlSegments(&ver, layout->second.pages);

        // Generate redirect files for subpages
        for (auto&& page : layout->second.pages) {
            auto fname = page.urlSegment + ".html";
            if (!page.pages.empty()) {
                auto cp = page.pages.begin();
                if (page.defChildPage != -1)
                    advance(cp, page.defChildPage);
                auto url = cp->urlSegment + ".html";
                if (!genRedirect(out, ver.tag + "/" + fname, url))
                    return false;
            }
            if (ver.defaultSource) {
                if (!genRedirect(out, fname, ver.tag + "/" + fname))
                    return false;
            }
        }
    }
    return true;
}

//===========================================================================
static void loadFavicon(
    Config * out,
    Config * spec,
    unsigned phase,
    const string & tag
) {
    if (spec->siteFavicon.empty())
        return;

    out->pendingWork += 1;
    loadContent(
        [out, spec, phase](auto && content) {
            if (!content.empty()) {
                Path fname("favicon.ico");
                if (out != spec)
                    fname.resolve(spec->tag);
                addOutput(out, fname, CharBuf(content), false);
            }
            genSite(out, phase);
        },
        *out,
        tag,
        out->siteFavicon
    );
}

//===========================================================================
static void genSite(Config * out, unsigned phase) {
    if (appStopping()) {
        if (--out->pendingWork == 0)
            delete out;
        return;
    }

    unsigned what = 0;

    if (phase == what++) {
        assert(!out->pendingWork);
        auto own = unique_ptr<Config>(out);

        // Generate infrastructure files for site.
        if (!genEmbeddedStatics(out))
            return;

        // This passthrough task (needed if all else is removed).
        out->pendingWork = 1;

        // Load favicon.ico.
        loadFavicon(out, out, what, "HEAD");

        // Load site files
        for (auto&& file : out->files) {
            out->pendingWork += 1;
            loadContent(
                [out, &file, what](auto && content) {
                    if (!content.empty()) {
                        Path fname(file.url);
                        addOutput(out, fname, CharBuf(content), false);
                    }
                    genSite(out, what);
                },
                *out,
                file.tag,
                file.file
            );
        }

        // Load layouts of all versions.
        for (auto&& ver : out->versions) {
            auto layname = ver.layout;

            if (!layname.empty()) {
                // If a layout was specified it overrides the configuration at
                // the tag. Especially useful for old tags with no config file.
            } else {
                // Load version of docgen.xml at the tag.
                out->pendingWork += 1;
                loadContent(
                    [out, &ver, what](auto && content) {
                        if (ver.cfg = loadConfig(
                            &content,
                            out->configFile,
                            out->gitRoot,
                            fLoadSite
                        )) {
                            ver.cfg->tag = ver.tag;
                        }
                        genSite(out, what);
                    },
                    *out,
                    ver.tag,
                    out->configFile
                );
            }
        }

        own.release();
        phase = what;
    }

    if (phase == what++) {
        if (--out->pendingWork) {
            // Still have more layouts to load.
            return;
        }
        auto own = unique_ptr<Config>(out);

        if (!genRedirects(out))
            return;

        // This passthrough task (needed if all else is removed).
        out->pendingWork = 1;

        // Generate pages
        for (auto && ver : out->versions) {
            auto spec = ver.cfg ? ver.cfg.get() : out;
            if (!spec->versionsByTag.contains(ver.tag)) {
                logMsgError() << out->configFile << ", tag '" << ver.tag
                    << "': tagged version of config file has matching no "
                        "Version/@tag";
                return appSignalShutdown(EX_DATAERR);
            }
            auto layname = spec->versionsByTag[ver.tag]->layout;
            if (layname.empty())
                layname = "default";
            auto layout = spec->layouts.find(layname);

            // Load favicon.ico
            if (spec != out) {
                // Version has it's own config, and therefore could have it's
                // own favicon.
                loadFavicon(out, spec, what, ver.tag);
            } else {
                // Version has no config; it's relying on the HEAD versions
                // favicon (or lack thereof).
            }

            // Generate pages for version
            for (auto && rootPage : layout->second.pages) {
                vector<Page *> pageList;
                pageList.reserve(rootPage.pages.size());
                if (!rootPage.file.empty()) {
                    pageList.push_back(&rootPage);
                } else {
                    for (auto && page : rootPage.pages) {
                        if (!page.file.empty())
                            pageList.push_back(&page);
                    }
                }
                for (auto && page : pageList) {
                    out->pendingWork += 1;
                    auto info = new GenPageInfo({ out, ver, *page });
                    info->fn = [info, what]() {
                        genSite(info->out, what);
                        delete info;
                    };
                    genPage(info);
                }
            }
        }

        own.release();
        phase = what;
    }

    if (phase == what++) {
        if (--out->pendingWork) {
            // Still have more pages to generate.
            return;
        }
        auto own = unique_ptr<Config>(out);

        // Replace site output directory with all the new files.
        auto odir = Path(out->siteDir).resolve(out->configFile.parentPath());
        if (!writeOutputs(odir, out->outputs))
            return;

        // Clean up
        auto count = out->outputs.size();

        logMsgInfo() << count << " generated files.";
        if (int errs = logGetMsgCount(kLogTypeError)) {
            ConsoleScopedAttr attr(kConsoleError);
            cerr << "Generation failures: " << errs << endl;
        } else {
            ConsoleScopedAttr ca(kConsoleCheer);
            logMsgInfo() << "Website generated successfully.";
        }

        logPauseStopwatch();
        return appSignalShutdown(EX_OK);
    }

    assert(!"unknown phase");
}


/****************************************************************************
*
*   Command line
*
***/

static void genCmd(Cli & cli);

//===========================================================================
CmdOpts::CmdOpts() {
    Cli cli;
    cli.command("site")
        .desc("Generate website files")
        .action(genCmd);
    cli.opt(&cfgfile, "c conf")
        .desc("docgen site configuration to process.")
        .defaultDesc("{GIT_ROOT}/docs/docgen.xml");
}

//===========================================================================
static void genCmd(Cli & cli) {
    auto cfg = loadConfig(s_opts.cfgfile, fLoadSite);
    if (!cfg)
        return cli.fail(EX_DATAERR);
    if (cfg->siteDir.empty()) {
        logMsgError() << cfg->configFile
            << ": Output directory for site unspecified.";
        return cli.fail(EX_DATAERR);
    }

    ostringstream os;
    os << "Making WEBSITE files from '" << cfg->configFile
        << "' to '" << cfg->siteDir << "'.";
    auto out = logMsgInfo();
    cli.printText(out, os.str());
    genSite(cfg.release());
    cli.fail(EX_PENDING);
}
