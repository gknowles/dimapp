// Copyright Glen Knowles 2018 - 2024.
// Distributed under the Boost Software License, Version 1.0.
//
// resupd.cpp - resupd
#include "pch.h"
#pragma hdrstop

using namespace std;
using namespace Dim;


/****************************************************************************
*
*   Tuning parameters
*
***/

const VersionInfo kVersion = { 1, 0 };


/****************************************************************************
*
*   Helpers
*
***/

constexpr int kMaxWidth = 78;

//===========================================================================
inline static void writeStrChar(
    ostream & os,
    int & pos,
    unsigned char ch,
    unsigned char next
) {
    if (ch >= ' ' && ch <= 126 && ch != '\\' && ch != '"') {
        if (pos >= kMaxWidth - 1) {
            os << "\"\n    \"";
            pos = 5;
        }
        os << ch;
        pos += 1;
        return;
    }

    if (pos >= kMaxWidth - 2) {
        os << "\"\n    \"";
        pos = 5;
    }
    auto digits = 3;
    switch (ch) {
    case '"': os << "\\\""; pos += 2; break;
    case '\\': os << "\\\\"; pos += 2; break;
    case '\a': os << "\\a"; pos += 2; break;
    case '\b': os << "\\b"; pos += 2; break;
    case '\f': os << "\\f"; pos += 2; break;
    case '\n': os << "\\n"; pos += 2; break;
    case '\r': os << "\\r"; pos += 2; break;
    case '\t': os << "\\t"; pos += 2; break;
    case '\v': os << "\\v"; pos += 2; break;
    default:
        if (ch < 8) {
            digits = 1;
        } else if (ch < 64) {
            digits = 2;
        }
        if (pos >= kMaxWidth - digits - 1) {
            os << "\"\n    \"";
            pos = 5;
        }
        if (next >= '0' && next <= '7' && pos < kMaxWidth - digits - 2) {
            digits = 3;
        }
        os << '\\';
        switch (digits) {
        case 3:
            os << (ch >> 6) % 8;
            [[fallthrough]];
        case 2:
            os << (ch >> 3) % 8;
            [[fallthrough]];
        case 1:
            os << ch % 8;
        }
        pos += digits + 1;
        break;
    }
}

//===========================================================================
[[maybe_unused]]
static void writeStrContent(ostream & os, string_view content) {
    os << "\n    \"";
    auto pos = 5;
    if (!content.empty()) {
        unsigned char prev = content.front();
        for (unsigned char ch : content.substr(1)) {
            writeStrChar(os, pos, prev, ch);
            prev = ch;
        }
        writeStrChar(os, pos, prev, '\0');
    }
    os << "\";\n";
}

//===========================================================================
static void writeContent(ostream & os, string_view content) {
    os << "{";
    auto pos = kMaxWidth;
    auto cpos = 0;
    for (unsigned char ch : content) {
        auto digits = 3;
        if (ch < 10) {
            digits = 1;
        } else if (ch < 100) {
            digits = 2;
        }
        if (pos > kMaxWidth - digits - 1) {
            os << "\n    ";
            pos = 5;
        }
        os << (int) ch;
        if (++cpos == content.size())
            break;
        os << ',';
        pos += digits + 1;
    }
    os << "\n};\n";
}

//===========================================================================
static void writeCpp(ostream & os, string_view target, string_view content) {
    os << "// " << Path(target).filename() << '\n'
        << "// Generated by resupd v" << toString(appVersion()) << '\n'
        << 1 + R"(
// clang-format off
#include "pch.h"
#pragma hdrstop

using namespace std;


/****************************************************************************
*
*   Content
*
***/

const uint8_t s_data[] = )";

    writeContent(os, content);

    os << 1 + R"(

//===========================================================================
string_view resWebSiteContent() {
    return {(const char *) s_data, size(s_data)};
}
)";
}


/****************************************************************************
*
*   Application
*
***/

static struct CmdOpts {
    Path target;
    Path src;
    enum { kResource, kCpp } otype;
    bool verbose;

    CmdOpts();
} s_opts;

//===========================================================================
CmdOpts::CmdOpts() {
    Cli cli;
    cli.helpNoArgs();
    cli.sortKey("2");
    cli.opt(&target, "<outfile>")
        .desc("Usually an executable for resource target or a source file "
            "for c++ target.");
    cli.opt(&src, "<srcdir>")
        .desc("Directory of resources to write to target.");

    cli.group("Output Type").sortKey("1");
    cli.opt(&otype, "r", kResource).flagValue(true)
        .desc("Update windows file resource.");
    cli.opt(&otype, "c", kCpp).flagValue()
        .desc("Write data as c++ source file.");

    cli.opt(&verbose, "v", false)
        .desc("Verbose list of changes.");
}

//===========================================================================
static void app(Cli & cli) {
    ResHandle h;
    Finally rclose{ [&]() { resClose(h); } };
    ResFileMap prev;
    if (s_opts.otype == CmdOpts::kResource) {
        s_opts.target.defaultExt("exe");
        h = resOpenForUpdate(s_opts.target);
        if (!h)
            return appSignalShutdown(EX_DATAERR);
        if (!prev.parse(resLoadData(h, kResWebSite))) {
            prev.clear();
            logMsgWarn() << "Invalid website resource: " << s_opts.target;
        }
    } else {
        s_opts.target.defaultExt("cpp");
    }

    cout << "Updating '" << s_opts.target << "' from '" << s_opts.src
        << "'" << endl;

    unsigned added = 0;
    unsigned updated = 0;
    ResFileMap files;
    for (auto&& fn : fileGlob(s_opts.src, "**")) {
        string content;
        if (auto ec = fileLoadBinaryWait(&content, fn.path); ec)
            return appSignalShutdown(EX_DATAERR);
        auto path = fn.path.str().substr(s_opts.src.size());
        if (path[0] != '/')
            path.insert(0, "/");
        TimePoint mtime;
        fileLastWriteTime(&mtime, fn.path);
        if (auto ent = prev.find(path)) {
            if (ent->mtime != mtime || ent->content != content) {
                updated += 1;
                if (s_opts.verbose)
                    cout << path << " updated" << endl;
            }
            prev.erase(path);
        } else {
            added += 1;
            if (s_opts.verbose)
                cout << path << " added" << endl;
        }
        files.insert(path, mtime, move(content));
    }
    auto removed = (unsigned) prev.size();

    if (added + updated + removed == 0) {
        cout << "Resources: " << files.size() << " (0 changed)" << endl;
        return appSignalShutdown(EX_OK);
    }

    if (s_opts.verbose) {
        for (auto&& [name, ent] : prev)
            cout << name << " removed" << endl;
    }

    CharBuf out;
    files.copy(&out);

    if (s_opts.otype == CmdOpts::kResource) {
        if (!resUpdate(h, kResWebSite, out.view()))
            return appSignalShutdown(EX_DATAERR);

        rclose = {};
        if (!resClose(h, true))
            return appSignalShutdown(EX_DATAERR);
    } else {
        using enum Dim::File::OpenMode;

        ostringstream os;
        writeCpp(os, s_opts.target, out.view());
        auto content = os.view();
        bool found = false;
        if (auto ec = fileExists(&found, s_opts.target); !ec && found) {
            string oldContent;
            if (fileLoadBinaryWait(&oldContent, s_opts.target))
                return appSignalShutdown(EX_DATAERR);
            if (oldContent == content) {
                cout << "Resources: " << files.size() << " (0 changed)"
                    << endl;
                return appSignalShutdown(EX_OK);
            }
        }
        FileHandle f;
        auto ec = fileOpen(
            &f,
            s_opts.target,
            fReadWrite | fCreat | fTrunc | fBlocking
        );
        if (!ec) {
            fileAppendWait(nullptr, f, content.data(), content.size());
            fileClose(f);
        }
    }

    ConsoleScopedAttr attr{kConsoleNote};
    cout << "Resources: " << files.size() << " ("
        << added << " added, "
        << updated << " updated, "
        << removed << " removed"
        << ")" << endl;
    return appSignalShutdown(EX_OK);
}


/****************************************************************************
*
*   Externals
*
***/

//===========================================================================
int main(int argc, char * argv[]) {
    Cli().action(app);
    return appRun(argc, argv, kVersion, "resupd");
}
