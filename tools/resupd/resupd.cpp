// Copyright Glen Knowles 2018 - 2021.
// Distributed under the Boost Software License, Version 1.0.
//
// resupd.cpp - resupd
#include "pch.h"
#pragma hdrstop

using namespace std;
using namespace Dim;


/****************************************************************************
*
*   Declarations
*
***/

const char kVersion[] = "1.0";


/****************************************************************************
*
*   Helpers
*
***/

constexpr int kMaxWidth = 78;

//===========================================================================
inline static void writeStrChar(
    ostream & os,
    int & pos,
    unsigned char ch,
    unsigned char next
) {
    if (ch >= ' ' && ch <= 126 && ch != '\\' && ch != '"') {
        if (pos >= kMaxWidth - 1) {
            os << "\"\n    \"";
            pos = 5;
        }
        os << ch;
        pos += 1;
        return;
    }

    if (pos >= kMaxWidth - 2) {
        os << "\"\n    \"";
        pos = 5;
    }
    auto digits = 3;
    switch (ch) {
    case '"': os << "\\\""; pos += 2; break;
    case '\\': os << "\\\\"; pos += 2; break;
    case '\a': os << "\\a"; pos += 2; break;
    case '\b': os << "\\b"; pos += 2; break;
    case '\f': os << "\\f"; pos += 2; break;
    case '\n': os << "\\n"; pos += 2; break;
    case '\r': os << "\\r"; pos += 2; break;
    case '\t': os << "\\t"; pos += 2; break;
    case '\v': os << "\\v"; pos += 2; break;
    default:
        if (ch < 8) {
            digits = 1;
        } else if (ch < 64) {
            digits = 2;
        }
        if (pos >= kMaxWidth - digits - 1) {
            os << "\"\n    \"";
            pos = 5;
        }
        if (next >= '0' && next <= '7' && pos < kMaxWidth - digits - 2) {
            digits = 3;
        }
        os << '\\';
        switch (digits) {
        case 3: os << (ch >> 6) % 8;
        case 2: os << (ch >> 3) % 8;
        case 1: os << ch % 8;
        }
        pos += digits + 1;
        break;
    }
}

//===========================================================================
inline static void writeStrContent(ostream & os, string_view content) {
    os << "\n    \"";
    auto pos = 5;
    if (!content.empty()) {
        unsigned char prev = content.front();
        for (unsigned char ch : content.substr(1)) {
            writeStrChar(os, pos, prev, ch);
            prev = ch;
        }
        writeStrChar(os, pos, prev, '\0');
    }
    os << "\";\n";
}

//===========================================================================
static void writeContent(ostream & os, string_view content) {
    os << " {\n    ";
    auto pos = 5;
    auto cpos = 0;
    for (unsigned char ch : content) {
        auto digits = 3;
        if (ch < 10) {
            digits = 1;
        } else if (ch < 100) {
            digits = 2;
        }
        if (pos > kMaxWidth - digits - 1) {
            os << "\n    ";
            pos = 5;
        }
        os << (int) ch;
        if (++cpos == content.size())
            break;
        os << ',';
        pos += digits + 1;
    }
    os << "\n};\n";
}

//===========================================================================
static void writeCpp(ostream & os, string_view target, string_view content) {
    os << "// " << Path(target).filename() << '\n'
        << "// Generated by resupd " << kVersion << '\n'
        << 1 + R"(
// clang-format off
#include "pch.h"
#pragma hdrstop

using namespace std;


/****************************************************************************
*
*   Content
*
***/

static const uint8_t s_data[] =)";

    writeContent(os, content);

    os << 1 + R"(

//===========================================================================
string_view resWebSiteContent() {
    return {(const char *) s_data, size(s_data)};
}
)";
}


/****************************************************************************
*
*   Application
*
***/

//===========================================================================
static void app(int argc, char *argv[]) {
    Cli cli;
    cli.header("resupd v"s + kVersion + " (" __DATE__ ")")
        .helpNoArgs()
        .versionOpt(kVersion, "resupd");
    cli.sortKey("2");
    auto & target = cli.opt<Path>("<outfile>")
        .desc("Usually an executable for resource target or a source file "
            "for c++ target.");
    auto & src = cli.opt<Path>("<srcdir>")
        .desc("Directory of resources to write to target.");
    enum { kResource, kCpp } otype;
    cli.group("Output Type").sortKey("1");
    cli.opt(&otype, "r", kResource).flagValue(true)
        .desc("Update windows file resource.");
    cli.opt(&otype, "c", kCpp).flagValue()
        .desc("Write data as c++ source file.");
    if (!cli.parse(argc, argv))
        return appSignalUsageError();

    ResHandle h;
    Finally rclose{ [=]() { resClose(h); } };
    ResFileMap prev;
    if (otype == kResource) {
        target->defaultExt("exe");
        h = resOpenForUpdate(*target);
        if (!h)
            return appSignalShutdown(EX_DATAERR);
        if (!prev.parse(resLoadData(h, kResWebSite))) {
            prev.clear();
            logMsgWarn() << "Invalid website resource: " << *target;
        }
    } else {
        target->defaultExt("cpp");
    }

    cout << "Updating '" << *target << "' from '" << *src << endl;

    unsigned added = 0;
    unsigned updated = 0;
    ResFileMap files;
    for (auto & fn : FileIter{*src}) {
        string content;
        if (!fileLoadBinaryWait(&content, fn.path))
            return appSignalShutdown(EX_DATAERR);
        auto path = fn.path.str().substr(src->size());
        if (path[0] != '/')
            path.insert(0, "/");
        auto mtime = fileLastWriteTime(fn.path);
        if (auto ent = prev.find(path)) {
            if (ent->mtime != mtime || ent->content != content)
                updated += 1;
            prev.erase(path);
        } else {
            added += 1;
        }
        files.insert(path, mtime, move(content));
    }
    auto removed = (unsigned) prev.size();

    if (added + updated + removed == 0) {
        cout << "Resources: " << files.size() << " (0 changed)" << endl;
        return appSignalShutdown(EX_OK);
    }

    CharBuf out;
    files.copy(&out);

    if (otype == kResource) {
        if (!resUpdate(h, kResWebSite, out.view()))
            return appSignalShutdown(EX_DATAERR);

        rclose = {};
        if (!resClose(h, true))
            return appSignalShutdown(EX_DATAERR);
    } else {
        ostringstream os;
        writeCpp(os, *target, out.view());
        auto content = os.view();
        if (fileExists(*target)) {
            string oldContent;
            if (!fileLoadBinaryWait(&oldContent, *target))
                return appSignalShutdown(EX_DATAERR);
            if (oldContent == content) {
                cout << "Resources: " << files.size() << " (0 changed)"
                    << endl;
                return appSignalShutdown(EX_OK);
            }
        }
        auto f = fileOpen(
            *target,
            File::fReadWrite | File::fCreat | File::fTrunc | File::fBlocking
        );
        fileAppendWait(f, content.data(), content.size());
        fileClose(f);
    }

    ConsoleScopedAttr attr{kConsoleNote};
    cout << "Resources: " << files.size() << " ("
        << added << " added, "
        << updated << " updated, "
        << removed << " removed"
        << ")" << endl;
    return appSignalShutdown(EX_OK);
}


/****************************************************************************
*
*   Externals
*
***/

//===========================================================================
int main(int argc, char * argv[]) {
    return appRun(app, argc, argv);
}
